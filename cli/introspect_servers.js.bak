#!/usr/bin/env node
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport, getDefaultEnvironment } from '@modelcontextprotocol/sdk/client/stdio.js';
import fs from 'fs/promises';
import path from 'path';
import process from 'process';
import { exec } from 'child_process'; // Added for running CLI
import util from 'util'; // Added for promisify
import os from 'os'; // For potential future CPU count based concurrency

// --- Configuration ---
const NpmResultsInputFile = path.resolve(process.cwd(), '../npm_mcp_search_results2.json'); // Ensure absolute path
const TempManifestFile = path.resolve(process.cwd(), 'temp_mcp_manifest.json'); // Ensure absolute path, potentially move to os.tmpdir()?
const connectionTimeoutMs = 15000; // 15 seconds to connect and initialize
const requestTimeoutMs = 30000; // 30 seconds for list requests
const CliScriptPath = path.resolve(process.cwd(), './cli/bin/mcp-cli.js'); // Ensure absolute path
const CONCURRENCY_LIMIT = 1; // Max concurrent introspection tasks

const execPromise = util.promisify(exec); // Promisify exec

// --- Concurrency Helpers --- START

/**
 * A simple asynchronous lock.
 */
class Lock {
    constructor() {
        this._locked = false;
        this._waiting = [];
    }

    acquire() {
        return new Promise(resolve => {
            if (!this._locked) {
                this._locked = true;
                resolve();
            } else {
                this._waiting.push(resolve);
            }
        });
    }

    release() {
        if (this._waiting.length > 0) {
            const nextResolve = this._waiting.shift();
            nextResolve(); // Let the next waiting acquire the lock
        } else {
            this._locked = false;
        }
    }
}

/**
 * Runs async tasks from an iterable with a concurrency limit.
 * @template T
 * @param {number} concurrencyLimit Max number of tasks to run at once.
 * @param {Iterable<T>} iterable Input items to process.
 * @param {(item: T) => Promise<void>} iteratorFn Async function to process each item.
 */
async function asyncPool(concurrencyLimit, iterable, iteratorFn) {
    const executing = new Set();
    const errors = [];
    for (const item of iterable) {
        const p = Promise.resolve().then(() => iteratorFn(item)).catch(err => errors.push(err));
        executing.add(p);
        const clean = () => executing.delete(p);
        p.then(clean).catch(clean);
        if (executing.size >= concurrencyLimit) {
            await Promise.race(executing);
        }
    }
    await Promise.all(executing);
    if (errors.length > 0) {
        // Optionally, re-throw the first error or an aggregate error
        throw new Error(`Errors occurred during concurrent processing: ${errors.map(e => e.message).join(', ')}`);
    }
}

// --- Concurrency Helpers --- END

// Processed Status Codes:
// 0: Not processed
// 1: Processed, determined not an MCP server (e.g., connection/initial listTools failed, or other introspection issue)
// 2: Processed, introspection succeeded, but a subsequent step failed (e.g., manifest generation or API registration)
// 3: Processed, introspection and API registration successful

// --- Helper Functions ---

function timeoutPromise(ms, promise, errorMsg) {
    let timer;
    return Promise.race([
        promise,
        new Promise((_, reject) => {
            timer = setTimeout(() => reject(new Error(errorMsg)), ms);
        })
    ]).finally(() => clearTimeout(timer));
}

/**
 * Saves the entire data structure back to the JSON file.
 * @param {object} data The full data object (including timestamp and packages array).
 * @param {string} filePath The path to save the file.
 */
async function saveResults(data, filePath) {
    try {
        await fs.writeFile(filePath, JSON.stringify(data, null, 2));
        console.log(`Successfully updated results in ${filePath}`);
    } catch (writeError) {
        console.error(`Error writing results to file ${filePath}: ${writeError.message}`);
        // Depending on desired behavior, we might want to exit or retry
    }
}

/**
 * Generates an MCP manifest object from introspection results.
 * @param {object} results - The results object from introspectServer.
 * @returns {object|null} - The generated manifest object or null if essential info is missing.
 */
function generateManifest(results) {
    const packageName = results?.connectionParams?.packageName;
    if (!packageName) {
        console.error("Cannot generate manifest: Missing connectionParams.packageName in results.");
        return null;
    }

    const capabilitiesArray = [];
    (results.tools || []).forEach(tool => {
        capabilitiesArray.push({
            name: tool.name,
            type: 'tool',
            description: tool.description || `${tool.name} tool`
        });
    });
    (results.resources || []).forEach(resource => {
        capabilitiesArray.push({
            name: resource.name,
            type: 'resource',
            description: resource.description || `${resource.name} resource`
        });
    });
    (results.prompts || []).forEach(prompt => {
        capabilitiesArray.push({
            name: prompt.name,
            type: 'prompt',
            description: prompt.description || `${prompt.name} prompt`
        });
    });

    if (capabilitiesArray.length === 0) {
         console.warn(`Warning: No capabilities found for ${packageName}. Manifest might be rejected if capabilities array cannot be empty.`);
    }

    const manifest = {
        name: results?.serverInfo?.name || packageName,
        description: results?.serverInfo?.description || `${packageName} MCP Server`,
        url: packageName,
        protocol_version: "MCP/1.0",
        capabilities: capabilitiesArray,
        installation: {
            command: 'npx',
            args: ['-y', packageName],
            env: {},
        },
    };

    if (results?.serverInfo?.auth) {
        manifest.auth = results.serverInfo.auth;
    }
    if (results?.serverInfo?.tags && Array.isArray(results.serverInfo.tags)) {
         manifest.tags = results.serverInfo.tags;
    }

    return manifest;
}


/**
 * Registers a manifest using the mcp-cli.js script.
 * @param {object} manifestJson - The manifest object to register.
 * @param {string} [apiUrl="https://mcpfinder.dev"] - The API URL for the MCP Finder registry.
 * @returns {Promise<{success: boolean, error?: string}>} - Object indicating success and optional error message.
 */
async function registerViaCli(manifestJson, apiUrl = "https://mcpfinder.dev") {
    if (!manifestJson) {
         console.error("Registration skipped: Manifest JSON is null or undefined.");
         return { success: false, error: "Manifest JSON is null or undefined." };
    }

    const manifestString = JSON.stringify(manifestJson, null, 2);
    const tempFilePath = TempManifestFile;

    console.log("--- Generated Manifest Content (for debugging validation) ---");
    console.log(manifestString);
    console.log("-------------------------------------------------------------");

    try {
        console.log(`Writing temporary manifest to ${tempFilePath}...`);
        await fs.writeFile(tempFilePath, manifestString);

        const command = \`node ${CliScriptPath} register ${tempFilePath} --api-url "${apiUrl}"\`;
        console.log(`Executing CLI registration: ${command} (Paths are absolute)`);

        const { stdout, stderr } = await execPromise(command, { env: process.env });

        console.log('CLI stdout:', stdout);
        if (stderr) {
            console.error('CLI stderr:', stderr); // Log stderr for debugging
        }

        if (stdout.includes('Registration successful!')) {
            console.log('Registration via CLI reported success.');
            return { success: true };
        } else {
            const errorMessage = 'Registration via CLI did not report success. Stdout did not contain "Registration successful!".';
            console.error(errorMessage);
            return { success: false, error: `${errorMessage} CLI stdout: ${stdout} CLI stderr: ${stderr}`.trim() };
        }

    } catch (error) {
        const errorMessage = `Error during CLI registration process: ${error.message}`;
        console.error(errorMessage);
        if (error.stdout) console.error('CLI stdout (on error):', error.stdout);
        if (error.stderr) console.error('CLI stderr (on error):', error.stderr);
        return { success: false, error: `${errorMessage} CLI stdout: ${error.stdout || ''} CLI stderr: ${error.stderr || ''}`.trim() };
    } finally {
        try {
            await fs.unlink(tempFilePath);
            console.log(`Deleted temporary manifest file: ${tempFilePath}`);
        } catch (unlinkError) {
            console.error(`Warning: Could not delete temporary manifest file ${tempFilePath}: ${unlinkError.message}`);
        }
    }
}


/**
 * Attempts to introspect a single server package.
 * @param {object} npmPackage - The package object from npm_mcp_search_results.json.
 * @returns {Promise<{status: string, results: object}>} - Status ('NOT_MCP', 'SUCCESS', 'FAILURE') and results.
 */
async function introspectServer(npmPackage) {
    const packageName = npmPackage?.package?.name;
    if (!packageName) {
        return { status: 'FAILURE', results: { error: 'Invalid package data, missing name.' } };
    }

    console.error(`\n--- Introspecting ${packageName} ---`);
    let client = null;
    let transport = null;
    let stderrOutput = '';
    let tempDir = null;

    const results = {
        connectionParams: {
            command: 'npx',
            packageName: packageName,
            args: [],
            env: {}
        },
        serverInfo: null,
        capabilities: null,
        tools: [],
        resources: [],
        prompts: [],
        error: null
    };

    try {
        const tempDirPrefix = path.join(os.tmpdir(), \`mcp-introspect-${packageName.replace(/[^a-zA-Z0-9]/g, '_')}-\`);
        tempDir = await fs.mkdtemp(tempDirPrefix);
        console.error(`Created temporary directory for ${packageName}: ${tempDir}`);

        const spawnArgs = [packageName];
        const transportEnv = { ...process.env };
        const defaultEnv = getDefaultEnvironment();
        const finalEnv = { ...transportEnv, ...defaultEnv };

        console.error(`Attempting to launch '${packageName}' via npx...`);
        transport = new StdioClientTransport({
            command: 'npx',
            args: spawnArgs,
            env: finalEnv,
            stderr: 'pipe',
            cwd: tempDir
        });

        if (transport.process?.stderr && typeof transport.process.stderr.on === 'function') {
            transport.process.stderr.on('data', (data) => {
                stderrOutput += data.toString();
            });
             transport.process.stderr.on('error', (err) => {
                  stderrOutput += \`[STDERR_ERROR: ${err.message}]\`;
             });
             transport.process.on('error', (err) => {
                 stderrOutput += \`[PROCESS_ERROR: ${err.message}]\`;
             });
             transport.process.on('exit', (code, signal) => {
                 stderrOutput += \`[PROCESS_EXIT code=${code} signal=${signal}]\`;
             });
        } else {
            console.error("Warning: Could not attach stderr listener (transport.process or stderr might be null/undefined, or process exited too fast).");
        }

        client = new Client({ name: 'mcp-introspector', version: '1.0.0' });
        console.error(`Connecting to ${packageName}...`);
        await timeoutPromise(
            connectionTimeoutMs,
            client.connect(transport),
            \`Connection timeout for ${packageName}\`
        );
        console.error(`Connected to ${packageName}.`);

        console.error("Attempting initial listTools() to potentially initialize connection and check viability...");
        try {
             const initialToolsResult = await timeoutPromise(
                 requestTimeoutMs,
                 client.listTools(),
                 \`Initial listTools timeout for ${packageName}\`
             );
             results.tools = initialToolsResult.tools || [];
             console.error(\`Initial listTools call succeeded. Found ${results.tools.length} tools.\`);
        } catch (initialToolError) {
             results.error = \`Failed initial listTools: ${initialToolError.message}\`;
             throw new Error('LIST_TOOLS_FAILED'); // Specific error to be caught below
        }

        console.error("Attempting to capture ServerInfo and Capabilities (best effort)...");
        results.serverInfo = client.serverInfo;
        results.capabilities = client.serverCapabilities;
        if (results.serverInfo?.name) {
             console.error(\`Server Info captured: ${results.serverInfo.name} (Version: ${results.serverInfo.version || 'unknown'})\`);
        } else {
             console.warn(\`Warning: ServerInfo was not available after listTools succeeded.\`);
        }

        console.error("Proceeding with further introspection (resources/prompts)...");
        if (results.capabilities?.resources) {
             try {
                 const resourcesResult = await timeoutPromise(
                     requestTimeoutMs,
                     client.listResources(),
                     \`listResources timeout for ${packageName}\`
                 );
                 results.resources = resourcesResult.resources || [];
                 console.error(\`Found ${results.resources.length} resources.\`);
             } catch (resourceError) {
                 console.error(\`Error during listResources for ${packageName}: ${resourceError.message}\`);
                  if (!results.error) results.error = \`Failed listResources: ${resourceError.message}\`;
             }
         }
        if (results.capabilities?.prompts) {
             try {
                 const promptsResult = await timeoutPromise(
                     requestTimeoutMs,
                     client.listPrompts(),
                     \`listPrompts timeout for ${packageName}\`
                 );
                 results.prompts = promptsResult.prompts || [];
                 console.error(\`Found ${results.prompts.length} prompts.\`);
             } catch (promptError) {
                 console.error(\`Error during listPrompts for ${packageName}: ${promptError.message}\`);
                  if (!results.error) results.error = \`Failed listPrompts: ${promptError.message}\`;
             }
         }

        console.error(\`--- Finished ${packageName} (Success) ---\`);
        await client.close().catch(closeErr => console.error(\`Error closing client on success: ${closeErr.message}\`));
        return { status: 'SUCCESS', results };

    } catch (error) {
        const stderrSnippet = stderrOutput.substring(0, 500) + (stderrOutput.length > 500 ? '...' : '');
        // Ensure results.error has the most relevant error message from the catch block
        results.error = \`${results.error || error.message}. Stderr: ${stderrSnippet}\`.trim();


        let finalStatus = 'FAILURE';
        if (stderrOutput.includes('command not found') || stderrOutput.includes('Not found') || stderrOutput.includes('Cannot find module') || error.code === 'ENOENT') {
             console.error(\`[${packageName}] stderr or error suggests package not found or failed execution. Assuming NOT_MCP.\`);
             finalStatus = 'NOT_MCP';
        }
        else if (error.message === 'LIST_TOOLS_FAILED') {
             console.error(\`[${packageName}] Initial listTools failed. Assuming NOT_MCP.\`);
             finalStatus = 'NOT_MCP';
        }
        else if (error.message.includes("timeout for") || error.message.includes("closed before handshake")) {
             console.error(\`[${packageName}] Connection timed out or closed early. Assuming NOT_MCP.\`);
             finalStatus = 'NOT_MCP';
        }

        console.error(\`--- Finished ${packageName} (${finalStatus}) --- Error: ${results.error}\`);
        if (client && client.isConnected) {
             await client.close().catch(closeErr => console.error(\`[${packageName}] Error closing client during error handling: ${closeErr.message}\`));
        } else if (transport?.process) {
            transport.process.kill('SIGTERM');
        }
        return { status: finalStatus, results };
    } finally {
        if (tempDir) {
            try {
                await fs.rm(tempDir, { recursive: true, force: true });
            } catch (cleanupError) {
                console.error(\`[${packageName}] Warning: Failed to remove temporary directory ${tempDir}: ${cleanupError.message}\`);
            }
        }
    }
}

// --- Main Execution ---

async function main() {
    if (!process.env.MCPFINDER_REGISTRY_SECRET) {
        console.error('Error: MCPFINDER_REGISTRY_SECRET environment variable is not set.');
        console.error('This secret is required to attempt registration of successfully introspected MCP servers.');
        console.error('Please set this environment variable and try running the script again.');
        process.exit(1);
    }

    let npmResultsData;
    let fileContent = '';
    try {
        fileContent = await fs.readFile(NpmResultsInputFile, 'utf-8');
        npmResultsData = JSON.parse(fileContent);
        if (!npmResultsData || !Array.isArray(npmResultsData.packages)) {
            throw new Error("Invalid input file format. Expected object with 'packages' array.");
        }
        console.log(\`Found ${npmResultsData.packages.length} total packages in the input file.\`);
    } catch (readError) {
        console.error(\`Error processing input file ${NpmResultsInputFile}:\`);
        if (readError.code === 'ENOENT') {
            console.error(\`Reason: File not found.\`);
        } else if (readError instanceof SyntaxError) {
            console.error(\`Reason: Could not parse JSON. Error: ${readError.message}\`);
        } else {
            console.error(\`Reason: Other read/parse error: ${readError.message}\`);
        }
        process.exit(1);
    }

    const allPackages = npmResultsData.packages;
    const unprocessedPackages = allPackages.filter(p => p.processed === 0);
    let packagesToProcess;

    if (unprocessedPackages.length > 0) {
        packagesToProcess = [unprocessedPackages[0]]; // Take only the first unprocessed package
        console.log(\`Filtered to ${unprocessedPackages.length} unprocessed packages. Selecting the first one for introspection: ${packagesToProcess[0]?.package?.name || 'N/A'}\`);
    } else {
        packagesToProcess = [];
        console.log("No unprocessed packages found.");
    }

    if (packagesToProcess.length === 0) {
        console.log("No packages require processing.");
        return;
    }

    console.log(\`Starting processing for ${packagesToProcess.length} package(s) with concurrency ${CONCURRENCY_LIMIT}...\`);

    let processedCount = 0;
    let successCount = 0;
    let notMcpCount = 0;
    let failureCount = 0;
    const totalToProcess = packagesToProcess.length; // Use the count of packages we are actually processing
    const saveLock = new Lock();

    const processPackage = async (npmPackage) => {
        const originalIndex = allPackages.findIndex(p => p.package.name === npmPackage.package.name); // Find index in original full array
        const currentPackageNum = ++processedCount;
        const packageName = npmPackage?.package?.name || \`unknown_package_${originalIndex}\`;

        console.log(\`\n[${currentPackageNum}/${totalToProcess}] Starting: ${packageName}\`);

        const { status: introspectionStatus, results: introspectionResults } = await introspectServer(npmPackage);

        let finalStatus = 0;
        let introspectionErrorMsg = null;
        let registrationErrorMsg = null;

        if (introspectionStatus === 'NOT_MCP') {
            introspectionErrorMsg = introspectionResults.error || "Determined not an MCP server.";
            console.log(\`[${packageName}] Result: NOT_MCP (${introspectionErrorMsg})\`);
            finalStatus = 1;
            notMcpCount++;
        } else if (introspectionStatus === 'FAILURE') {
            introspectionErrorMsg = introspectionResults.error || "Introspection process failed.";
            console.log(\`[${packageName}] Result: INTROSPECTION FAILED. Error: ${introspectionErrorMsg}\`);
            finalStatus = 2; // Fall into general failure, as registration won't be attempted
            failureCount++;
        } else if (introspectionStatus === 'SUCCESS') {
            console.log(\`[${packageName}] Result: INTROSPECTION SUCCEEDED. Attempting manifest generation and registration...\`);
            const manifest = generateManifest(introspectionResults);
            if (manifest) {
                const registrationResult = await registerViaCli(manifest); // Uses default API URL
                if (registrationResult.success) {
                    console.log(\`[${packageName}] Result: REGISTRATION SUCCEEDED.\`);
                    finalStatus = 3;
                    successCount++;
                } else {
                    registrationErrorMsg = registrationResult.error || "Registration with API failed (unknown reason).";
                    console.log(\`[${packageName}] Result: INTROSPECTION SUCCEEDED, REGISTRATION FAILED. Error: ${registrationErrorMsg}\`);
                    finalStatus = 2;
                    failureCount++;
                }
            } else {
                 introspectionErrorMsg = "Manifest generation failed after successful introspection.";
                 console.log(\`[${packageName}] Result: INTROSPECTION SUCCEEDED, MANIFEST GENERATION FAILED.\`);
                 finalStatus = 2; // Still a failure if manifest cannot be generated
                 failureCount++;
            }
        }

        await saveLock.acquire();
        try {
            if (originalIndex !== -1) {
                const packageInGlobalArray = npmResultsData.packages[originalIndex];
                packageInGlobalArray.processed = finalStatus;
                packageInGlobalArray.introspectionError = introspectionErrorMsg; // Will be null if no error
                packageInGlobalArray.registrationError = registrationErrorMsg;   // Will be null if no error or not attempted

                // Clear old errors if current step succeeded
                if (introspectionStatus === 'SUCCESS' && !introspectionErrorMsg) delete packageInGlobalArray.introspectionError;
                if (registrationErrorMsg === null && finalStatus === 3) delete packageInGlobalArray.registrationError;

            } else {
                 console.error(\`Error: Could not find package ${packageName} in original list to update status.\`);
            }

            npmResultsData.collectionTimestamp = new Date().toISOString();
            await saveResults(npmResultsData, NpmResultsInputFile);

            let statusReason = "";
            if (finalStatus === 1) statusReason = introspectionErrorMsg ? `Not MCP: ${introspectionErrorMsg}` : "Not MCP";
            else if (finalStatus === 2) {
                if (introspectionErrorMsg) statusReason = \`Introspection Problem: ${introspectionErrorMsg}\`;
                else if (registrationErrorMsg) statusReason = \`Registration Failed: ${registrationErrorMsg}\`;
                else statusReason = "Processing Problem";
            }
            else if (finalStatus === 3) statusReason = "Success";

            console.log(\`[${currentPackageNum}/${totalToProcess}] Saved: ${packageName} (Status: ${finalStatus} - ${statusReason}). Counts: Success=${successCount}, NotMCP=${notMcpCount}, Failed=${failureCount}\`);
        } catch (saveErr) {
            console.error(\`[${packageName}] CRITICAL: Failed to save results: ${saveErr.message}\`);
        } finally {
            saveLock.release();
        }
    };

    try {
        await asyncPool(CONCURRENCY_LIMIT, packagesToProcess, processPackage);
    } catch (poolError) {
        console.error(\`Error occurred during concurrent processing pool: ${poolError.message}\`);
    }

    console.log(\`\nProcessing complete for the selected package(s).\`);
    // Final counts reflect only the packages processed in this run if it's a partial run.
    // For overall stats, one would need to parse the whole file again.
    console.log(\`Run Counts: Success=${successCount}, NotMCP=${notMcpCount}, Failed=${failureCount}, Processed in this run=${processedCount}\`);
    console.log(\`Results saved in ${NpmResultsInputFile}\`);
}

main().catch(err => {
    console.error("\nUnhandled error in main execution:", err);
    process.exit(1);
});
